# 技術ブログ構成案：独自のPythonシミュレータで加速する自動運転AI開発

<!-- 🖼️ アイキャッチ: 障害物を回避しながら走行する動画（GIF推奨） -->

## 1. はじめに：なぜシミュレータを自作したのか

### 背景と動機
- **自動運転AIチャレンジ2025** のTiny Lidar Net教材をベースにした取り組み。
- **将来の目標**: 複数台でのEnd-to-End同時レースの可能性を探る。
  - そのために、まずは1台での障害物回避を確実にできるようにする。

### 既存環境の課題
- Unity + ROS 2のバイナリシミュレータは重く、並列実行が困難。
- 任意の初期位置や障害物配置の自由度が低い。

### 本プロジェクトで実現すること
- Pythonベースの軽量プロキシ・シミュレータの構築。
- MLOpsフローによる開発サイクルの自動化・高速化。

---

## 2. システム同定：Unityの挙動をPythonで再現する

### データ駆動アプローチ
- Unity環境でPure Pursuitを使って走行ログ（MCAP形式）を収集。
- ステアリング応答と縦方向ダイナミクスをパラメータ同定。

<!-- 🖼️ 図: ステアリング応答の比較グラフ
     - 横軸: 時間、縦軸: ステアリング角
     - Unity（実測）vs 自作シミュレータ（FOPDTモデル）のオーバーレイ -->

### モデリングの詳細
- **ステアリング応答**: 無駄時間＋1次遅れ系（FOPDT）を採用。
- **縦方向ダイナミクス**: 空気抵抗（$v^2$）、コーナリングドラッグ（$|steer| \cdot v^2$）。

<!-- 🖼️ 図: 縦方向ダイナミクス（速度）の比較グラフ（オプション）
     - Unity vs 自作シミュレータの速度推移 -->

<!-- 📝 コードスニペット: dynamics.py のFOPDTモデル部分 -->

### 課題と今後
- **Unityとの差異**: Unityバイナリの方がステアで大回りになる傾向がある。
- 現状は「データ収集戦略の検証」が主目的なので許容。今後、Unity/ROS 2側の改善に活用予定。

---

## 3. 障害物回避への挑戦：データ収集戦略

### 段階的なアプローチ
1. **まず障害物なし**で3m/sで走行できるモデルを構築。
2. 必要なデータ量の目安を把握。
3. **障害物ありのデータを追加**し、回避モデルを構築。

### 2種類のデータ収集

| 種類 | 目的 | エピソード数 (Train/Val) |
|:---|:---|:---|
| **Random Start** | センターライン復帰＆走行の学習 | 800 / 200 |
| **Track Forward** | 障害物回避の学習 | 8000 / 2000 |

#### Random Start

<!-- 🖼️ 図: Random Start の概念図
     - コース上のランダムな位置から矢印が出ているイメージ
     - 「位置・姿勢・速度がランダム」を視覚化 -->

- コース上のランダムな位置・姿勢・速度から開始。
- 「コースのどこにいても中央に戻れる」基本動作を学習。

<!-- 📝 コードスニペット: initial_state_sampling.yaml の設定例 -->

#### Track Forward

<!-- 🖼️ 図: Track Forward の概念図（重要）
     - 「初期位置から10m先に障害物」「7秒で回避完了」を図解
     - 道路上に車両と障害物を配置したシンプルな俯瞰図 -->

- ランダムなスタート地点から、**初期位置の道のり10m先**に障害物を配置。
- 1エピソード約7秒（回避が終わるちょうど良い長さ）。
- **回避のデータをピンポイントで効率よく収集**できる工夫。

### 障害物の配置
- **個数**: 1個（複数同時回避は将来課題）。
- **サイズ**: 自車両と同じ（複数台走行を想定）。
- **距離**: 常に10m先（偏りがある点は認識しつつ、まずはシンプルに）。

### なぜPure Pursuitを「教師」にしたか
- 人間のマニュアル操作は時間がかかり、最適性も高くない。
- MPCも実装済みだが、まずは単純なPure Pursuitで十分と判断。
- 「難しい状況での回避」を目指しているわけではないため。

### 失敗データは含めない
- **理由**: 失敗データを含めると性能が悪化した経験。
- 失敗は学習しても成功に変わらない。その分を成功データに回す方がデータ効率が良い。

### エピソード時間の工夫
- **長すぎると問題**: 真ん中を走っているだけのデータが増えすぎる。
- 回避が終わるギリギリの7秒に調整し、回避行動のデータ密度を最大化。

---

## 4. MLOpsフロー：自動化された開発パイプライン

<!-- 🖼️ 図: パイプラインの全体図（Mermaid推奨）
     - Collection → Extraction → Training → Evaluation の流れ -->

### パイプライン構成 (`run_mlops_pipeline.py`)
1. **Parallel Collection**: Joblibで並列化（約4.4倍高速化）。
2. **Combined Extraction**: 成功データのみをフィルタリング。
3. **Training**: MLflow / WandB で実験管理。
4. **Evaluation**: Pure Pursuit（ベースライン）とAIモデルを比較評価。

<!-- 🖼️ スクリーンショット: WandB/MLflowの学習曲線
     - Loss（Train/Val）の収束の様子 -->

### 入れて良かった機能
- **result.jsonにFoxgloveリンク**: すぐに走行を可視化できる。
- **Collision等の統計グラフ**: 成功率や失敗原因が一目でわかる。

<!-- 🖼️ スクリーンショット: result.json + Foxgloveリンクの画面
     - 「クリックするとすぐ可視化できる」利便性をアピール -->

---

## 5. Tiny Lidar Netについて

### アーキテクチャ
- 教材のまま変更なし。
- Lidarスキャン(1080点) → ステアリング・スロットル出力。

### 低速での検証理由
- Tiny Lidar Netの構造的に、車両運動の遅れ（ステアリング応答等）に対応できない。
- まずは遅れの影響が小さい**低速（3m/s）**で検証。

### 気になる点
- ステア出力（±0.34rad）を正規化せずにtanhを使っている点。
- Linearでも問題ないと思うが、一旦は放置。

---

## 6. 結果と考察

### 成果

<!-- 🖼️ 動画: 成功走行（3m/s完走）
     - 自作シミュレータでの障害物回避 -->

- 自作シミュレータで**3m/sでの障害物回避・完走**を達成。

<!-- 🖼️ 動画: Unityバイナリでの走行（あれば）
     - 「自作で学習 → Unityで動作」の証拠 -->

- 自作環境で学習したモデルが**Unityバイナリ環境でも動作**。

### 課題

<!-- 🖼️ 動画: 失敗ケース（オプション）
     - コーナーで回避方向を間違える例 -->

- **コーナーでの回避方向の誤り**: 右か左かを間違える。
  - → 該当データを増やすことを検討中。
- **Unityとの挙動差**: 常に大回りになる傾向。
  - → 入力値に対する挙動差の詳細調査が今後の課題。

---

## 7. おわりに

### 教訓
- 高精度シミュレータをゼロから作るのではなく、**目的に特化したプロキシ環境**が有効。
- 失敗データより成功データの方がBehavioral Cloningには効果的。
- エピソード時間を短くし、学習したい行動のデータ密度を上げる工夫が重要。

### 今後の展望
- より高速な走行（15m/s等）への対応。
- 複数障害物の同時回避。
- 複数台でのE2Eレースへの挑戦。
